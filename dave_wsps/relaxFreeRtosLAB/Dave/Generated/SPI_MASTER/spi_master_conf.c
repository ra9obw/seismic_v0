/*********************************************************************************************************************
* DAVE APP Name : SPI_MASTER       APP Version: 4.3.22
*
* NOTE:
* This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
*********************************************************************************************************************/

/**
 * @cond
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version<br>
 *
 * 2015-02-20:
 *     - Guard is generated for dx0_input. This helps to cross check the dynamic mode change support<br>
 *
 * 2015-05-08:
 *     - Bug fix for code generation if advanced pin configuration is not enabled.<br>
 *     - Seperate code generation for full duplex mode<br>
 *     - Conditional code generation for parity error<br>
 *     - XMC_SPI_CH_EnableFEM() and XMC_SPI_CH_SetBitOrderLsbFirst() are generated conditionally<br>
 *     - Configuration for Leading/Training is added<br>
 *
 * 2015-06-20:
 *     - Code generation for parity error is generated after selecting the parity type and enabling the callback in 
 *        interrupt settings tab.<br>
 *     - word_length is added to SPI_MASTER_DYNAMIC_CONFIG_t, to support runtime change.<br>
 *     - Clock settings are updated with combo. So defined a map locally for clcok settings.
 *
 * 2015-07-07:
 *     - DYNAMIC_CONFIG_t is renamed as RUNTIME_t
 *
 * 2015-09-01:
 *     - 'gpio_mode_alternate_function' is renamed as 'gpio_output_alternate_function' and extended to support XMC14 devices.
 *
 * 2015-09-30:
 *     - dummy read are added for setena bit field.
 *
 * 2015-10-14:
 *     - new variable "spi_master_config_mode" to store the actual mode generated during initialisation.
 *     - bug fix: node pointer assignment for protocol event is generated always.  
 *     - XMC_USIC_CH_TriggerServiceRequest() is generated during init,  
 *     - receive start disable event is removed from the DMA callback to support the higher baudrate.
 *
 * 2016-01-20:
 *     - In DMA mode, TDV flag polling is added to ensure last byte is shifted out from the buffer.
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "spi_master.h"

/***********************************************************************************************************************
* LOCAL ROUTINES
***********************************************************************************************************************/
#if (SPI_MASTER_INTERRUPT_TRANSMIT_MODE == 1U)
/*
 * Function implements the data transmission. It is called from the transmit interrupt service handler.
 * Function pushes data to the output block and releases control. It is called again when the previous data is
 * transmitted. When transmit FIFO is used, the function sets the trigger limit based on the size of data to be
 * transmitted. This makes sure that the CPU usage is optimum.
 *
 * Note: The API is only meant for internal use. The implementation should not be modified.
 */
extern void SPI_MASTER_lTransmitHandler(const SPI_MASTER_t * const handle);
#endif
#if (SPI_MASTER_INTERRUPT_RECEIVE_MODE == 1U)
/*
 * Function implements the data reception. It is called from the receive interrupt service handler.
 * Function reads data from the receive block and updates the receive buffer. It is called again when the data is
 * received again. When receive FIFO is used, the function sets the trigger limit based on the size of data to be
 * received. This makes sure that the CPU usage is optimum.
 *
 * Note: The API is only meant for internal use. The implementation should not be modified.
 */
extern void SPI_MASTER_lReceiveHandler(const SPI_MASTER_t * const handle);
#endif
#if (SPI_MASTER_PARITY_ERROR == 1U)
/*
 * Function monitors the configured protocol interrupt flags. It is called from the protocol interrupt service handler.
 * Function reads the status of the SPI_MASTER channel and checks for configured flags in the APP GUI. If any callback
 * function is provided in the APP UI, it will be called when the selected flag is set.
 *
 * Note: The API is only meant for internal use. The implementation should not be modified.
 */
extern void SPI_MASTER_lProtocolHandler(const SPI_MASTER_t * const handle);
#endif
/***********************************************************************************************************************
* DATA STRUCTURES
***********************************************************************************************************************/

static SPI_MASTER_STATUS_t SPI4_lInit(void);
/* Data Transmit pin from SPI_MASTER */
const SPI_MASTER_GPIO_t SPI4_MOSI = 
{
  .port = (XMC_GPIO_PORT_t *)PORT2_BASE,
  .pin  = (uint8_t)5
};         
                                      
SPI_MASTER_GPIO_CONFIG_t SPI4_MOSI_Config = 
{ 
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT2,
    .output_level = XMC_GPIO_OUTPUT_LEVEL_HIGH,
    .output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE
  },
  .hw_control = XMC_GPIO_HWCTRL_DISABLED
};

/* Data Receive pin for SPI_MASTER */
const SPI_MASTER_GPIO_t SPI4_MISO = 
{
  .port = (XMC_GPIO_PORT_t *)PORT2_BASE,
  .pin  = (uint8_t)2
};

SPI_MASTER_GPIO_CONFIG_t SPI4_MISO_Config = 
{
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_INPUT_TRISTATE,
  },
                        
};

const SPI_MASTER_GPIO_t SPI4_SCLKOUT = 
{
  .port = (XMC_GPIO_PORT_t *)PORT2_BASE,
  .pin  = (uint8_t)4
};     

const SPI_MASTER_GPIO_CONFIG_t SPI4_SCLKOUT_Config = 
{ 
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT2,
    .output_level = XMC_GPIO_OUTPUT_LEVEL_HIGH,
    .output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE
}
};

XMC_SPI_CH_CONFIG_t SPI4_Channel_Config =
{
  .baudrate = 1000000U,
  .bus_mode = (XMC_SPI_CH_BUS_MODE_t)XMC_SPI_CH_BUS_MODE_MASTER,
  .selo_inversion = XMC_SPI_CH_SLAVE_SEL_INV_TO_MSLS,
  .parity_mode = XMC_USIC_CH_PARITY_MODE_NONE
};
              

const SPI_MASTER_CONFIG_t SPI4_Config  = 
{
  .channel_config          = &SPI4_Channel_Config,
  .fptr_spi_master_config  = SPI4_lInit,
  /* FIFO configuration */
  .tx_fifo_size            = (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
  .rx_fifo_size            = (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
  /* Clock Settings */
  .shift_clk_passive_level = XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED, 
  .slave_select_lines      = (uint8_t)0,
  .leading_trailing_delay  = (uint8_t)2,
  .spi_master_config_mode  = XMC_SPI_CH_MODE_STANDARD, /* spi master initial mode configured mode */
  .transmit_mode           = SPI_MASTER_TRANSFER_MODE_DIRECT,
  .receive_mode            = SPI_MASTER_TRANSFER_MODE_DIRECT,
   
  .tx_cbhandler            = NULL,
  .rx_cbhandler            = NULL,
  .parity_cbhandler        = NULL,
  .mosi_0_pin              = &SPI4_MOSI, /*!< mosi0 pin pointer*/
  .mosi_0_pin_config       = &SPI4_MOSI_Config,
  .mosi_1_pin              = &SPI4_MISO,
  .mosi_1_pin_config       = &SPI4_MISO_Config,
  .mosi_2_pin              = NULL,
  .mosi_2_pin_config       = NULL,
  .mosi_3_pin              = NULL,
  .mosi_3_pin_config       = NULL,
  .sclk_out_pin_config     = &SPI4_SCLKOUT_Config,
  .sclk_out_pin            = &SPI4_SCLKOUT,
  .slave_select_pin        = {NULL, NULL,
                              NULL, NULL,
                              NULL, NULL,
                              NULL, NULL
                             },
  .slave_select_pin_config = {NULL, NULL,
                              NULL, NULL,
                              NULL, NULL,
                              NULL, NULL
                             },

  .tx_sr   = (SPI_MASTER_SR_ID_t)SPI_MASTER_SR_ID_0,
  .rx_sr   = (SPI_MASTER_SR_ID_t)SPI_MASTER_SR_ID_0,
};
                           
SPI_MASTER_RUNTIME_t SPI4_runtime =
{
  .spi_master_mode = XMC_SPI_CH_MODE_STANDARD, /* spi master transmission mode */
  .word_length     = 8U,
                       
  #ifdef USIC0_C1_DX0_P2_2
  .dx0_input = SPI_MASTER_INPUT_A,
  #else
  .dx0_input = SPI_MASTER_INPUT_INVALID,
  #endif

  #ifdef USIC0_C1_DX0_P2_5
  .dx0_input_half_duplex = SPI_MASTER_INPUT_A,
  #else
  .dx0_input_half_duplex = SPI_MASTER_INPUT_INVALID,
  #endif
                           
  .tx_data_dummy = false,
  .rx_data_dummy = true,
  .tx_busy = false,
  .rx_busy = false
};
                  
SPI_MASTER_t SPI4 =
{
  .channel = XMC_SPI0_CH1, /* USIC channel */
  .config  = &SPI4_Config, /* spi master configuration structure pointer */
  .runtime = &SPI4_runtime,
};
                          
/*
 * @brief Configure the port registers and data input registers of SPI channel
 *
 * @param[in] handle Pointer to an object of SPI_MASTER configuration
 */
static SPI_MASTER_STATUS_t SPI4_lInit(void)
{
  SPI_MASTER_STATUS_t status;
  status = SPI_MASTER_STATUS_SUCCESS; 
  /* LLD initialization */
  XMC_SPI_CH_Init(XMC_SPI0_CH1, &SPI4_Channel_Config);
                             
  XMC_SPI_CH_DisableFEM(XMC_SPI0_CH1);
                              
  XMC_SPI_CH_SetBitOrderMsbFirst(XMC_SPI0_CH1);
          
  XMC_SPI_CH_SetWordLength(XMC_SPI0_CH1, (uint8_t)8);

  XMC_SPI_CH_SetFrameLength(XMC_SPI0_CH1, (uint8_t)64);

  /* Configure the clock polarity and clock delay */
  XMC_SPI_CH_ConfigureShiftClockOutput(XMC_SPI0_CH1,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK);
  /* Configure Leading/Trailing delay */
  XMC_SPI_CH_SetSlaveSelectDelay(XMC_SPI0_CH1, 2U);

               
  /* Configure the input pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)2, &SPI4_MISO_Config.port_config);

  /* Configure the data input line selected */
  XMC_SPI_CH_SetInputSource(XMC_SPI0_CH1, XMC_SPI_CH_INPUT_DIN0, (uint8_t)SPI_MASTER_INPUT_A);
  /* Start the SPI_Channel */
  XMC_SPI_CH_Start(XMC_SPI0_CH1);

  /* Configure the output pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, &SPI4_MOSI_Config.port_config);
    
  /* Initialize SPI SCLK out pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, &SPI4_SCLKOUT_Config.port_config);

  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI0_CH1,
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
                                      (uint32_t)SPI_MASTER_SR_ID_0);
            
  /* Configure transmit FIFO settings */
  XMC_USIC_CH_TXFIFO_Configure(XMC_SPI0_CH1,
                               48U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               1U);

  /* Configure the service interrupt nodes for standard transmit FIFO events */
               
  /* Configure receive FIFO settings */
  XMC_USIC_CH_RXFIFO_Configure(XMC_SPI0_CH1,
                               32U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               15U);
             
  return status;
}
static SPI_MASTER_STATUS_t SPI1_lInit(void);
/* Data Transmit pin from SPI_MASTER */
const SPI_MASTER_GPIO_t SPI1_MOSI = 
{
  .port = (XMC_GPIO_PORT_t *)PORT0_BASE,
  .pin  = (uint8_t)1
};         
                                      
SPI_MASTER_GPIO_CONFIG_t SPI1_MOSI_Config = 
{ 
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT2,
    .output_level = XMC_GPIO_OUTPUT_LEVEL_HIGH,
    .output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE
  },
  .hw_control = XMC_GPIO_HWCTRL_DISABLED
};

/* Data Receive pin for SPI_MASTER */
const SPI_MASTER_GPIO_t SPI1_MISO = 
{
  .port = (XMC_GPIO_PORT_t *)PORT0_BASE,
  .pin  = (uint8_t)0
};

SPI_MASTER_GPIO_CONFIG_t SPI1_MISO_Config = 
{
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_INPUT_TRISTATE,
  },
                        
};

const SPI_MASTER_GPIO_t SPI1_SCLKOUT = 
{
  .port = (XMC_GPIO_PORT_t *)PORT0_BASE,
  .pin  = (uint8_t)10
};     

const SPI_MASTER_GPIO_CONFIG_t SPI1_SCLKOUT_Config = 
{ 
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT2,
    .output_level = XMC_GPIO_OUTPUT_LEVEL_HIGH,
    .output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE
}
};

XMC_SPI_CH_CONFIG_t SPI1_Channel_Config =
{
  .baudrate = 10000000U,
  .bus_mode = (XMC_SPI_CH_BUS_MODE_t)XMC_SPI_CH_BUS_MODE_MASTER,
  .selo_inversion = XMC_SPI_CH_SLAVE_SEL_INV_TO_MSLS,
  .parity_mode = XMC_USIC_CH_PARITY_MODE_NONE
};
              

const SPI_MASTER_CONFIG_t SPI1_Config  = 
{
  .channel_config          = &SPI1_Channel_Config,
  .fptr_spi_master_config  = SPI1_lInit,
  /* FIFO configuration */
  .tx_fifo_size            = (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
  .rx_fifo_size            = (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
  /* Clock Settings */
  .shift_clk_passive_level = XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED, 
  .slave_select_lines      = (uint8_t)0,
  .leading_trailing_delay  = (uint8_t)2,
  .spi_master_config_mode  = XMC_SPI_CH_MODE_STANDARD, /* spi master initial mode configured mode */
  .transmit_mode           = SPI_MASTER_TRANSFER_MODE_DIRECT,
  .receive_mode            = SPI_MASTER_TRANSFER_MODE_DIRECT,
   
  .tx_cbhandler            = NULL,
  .rx_cbhandler            = NULL,
  .parity_cbhandler        = NULL,
  .mosi_0_pin              = &SPI1_MOSI, /*!< mosi0 pin pointer*/
  .mosi_0_pin_config       = &SPI1_MOSI_Config,
  .mosi_1_pin              = &SPI1_MISO,
  .mosi_1_pin_config       = &SPI1_MISO_Config,
  .mosi_2_pin              = NULL,
  .mosi_2_pin_config       = NULL,
  .mosi_3_pin              = NULL,
  .mosi_3_pin_config       = NULL,
  .sclk_out_pin_config     = &SPI1_SCLKOUT_Config,
  .sclk_out_pin            = &SPI1_SCLKOUT,
  .slave_select_pin        = {NULL, NULL,
                              NULL, NULL,
                              NULL, NULL,
                              NULL, NULL
                             },
  .slave_select_pin_config = {NULL, NULL,
                              NULL, NULL,
                              NULL, NULL,
                              NULL, NULL
                             },

  .tx_sr   = (SPI_MASTER_SR_ID_t)SPI_MASTER_SR_ID_0,
  .rx_sr   = (SPI_MASTER_SR_ID_t)SPI_MASTER_SR_ID_0,
};
                           
SPI_MASTER_RUNTIME_t SPI1_runtime =
{
  .spi_master_mode = XMC_SPI_CH_MODE_STANDARD, /* spi master transmission mode */
  .word_length     = 8U,
                       
  #ifdef USIC1_C1_DX0_P0_0
  .dx0_input = SPI_MASTER_INPUT_D,
  #else
  .dx0_input = SPI_MASTER_INPUT_INVALID,
  #endif

  #ifdef USIC1_C1_DX0_P0_1
  .dx0_input_half_duplex = SPI_MASTER_INPUT_D,
  #else
  .dx0_input_half_duplex = SPI_MASTER_INPUT_INVALID,
  #endif
                           
  .tx_data_dummy = false,
  .rx_data_dummy = true,
  .tx_busy = false,
  .rx_busy = false
};
                  
SPI_MASTER_t SPI1 =
{
  .channel = XMC_SPI1_CH1, /* USIC channel */
  .config  = &SPI1_Config, /* spi master configuration structure pointer */
  .runtime = &SPI1_runtime,
};
                          
/*
 * @brief Configure the port registers and data input registers of SPI channel
 *
 * @param[in] handle Pointer to an object of SPI_MASTER configuration
 */
static SPI_MASTER_STATUS_t SPI1_lInit(void)
{
  SPI_MASTER_STATUS_t status;
  status = SPI_MASTER_STATUS_SUCCESS; 
  /* LLD initialization */
  XMC_SPI_CH_Init(XMC_SPI1_CH1, &SPI1_Channel_Config);
                             
  XMC_SPI_CH_DisableFEM(XMC_SPI1_CH1);
                              
  XMC_SPI_CH_SetBitOrderMsbFirst(XMC_SPI1_CH1);
          
  XMC_SPI_CH_SetWordLength(XMC_SPI1_CH1, (uint8_t)8);

  XMC_SPI_CH_SetFrameLength(XMC_SPI1_CH1, (uint8_t)64);

  /* Configure the clock polarity and clock delay */
  XMC_SPI_CH_ConfigureShiftClockOutput(XMC_SPI1_CH1,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK);
  /* Configure Leading/Trailing delay */
  XMC_SPI_CH_SetSlaveSelectDelay(XMC_SPI1_CH1, 2U);

               
  /* Configure the input pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT0_BASE, (uint8_t)0, &SPI1_MISO_Config.port_config);

  /* Configure the data input line selected */
  XMC_SPI_CH_SetInputSource(XMC_SPI1_CH1, XMC_SPI_CH_INPUT_DIN0, (uint8_t)SPI_MASTER_INPUT_D);
  /* Start the SPI_Channel */
  XMC_SPI_CH_Start(XMC_SPI1_CH1);

  /* Configure the output pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT0_BASE, (uint8_t)1, &SPI1_MOSI_Config.port_config);
    
  /* Initialize SPI SCLK out pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT0_BASE, (uint8_t)10, &SPI1_SCLKOUT_Config.port_config);

  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI1_CH1,
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
                                      (uint32_t)SPI_MASTER_SR_ID_0);
            
  /* Configure transmit FIFO settings */
  XMC_USIC_CH_TXFIFO_Configure(XMC_SPI1_CH1,
                               16U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               1U);

  /* Configure the service interrupt nodes for standard transmit FIFO events */
               
  /* Configure receive FIFO settings */
  XMC_USIC_CH_RXFIFO_Configure(XMC_SPI1_CH1,
                               0U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               15U);
             
  return status;
}
static SPI_MASTER_STATUS_t SPI2_lInit(void);
/* Data Transmit pin from SPI_MASTER */
const SPI_MASTER_GPIO_t SPI2_MOSI = 
{
  .port = (XMC_GPIO_PORT_t *)PORT1_BASE,
  .pin  = (uint8_t)5
};         
                                      
SPI_MASTER_GPIO_CONFIG_t SPI2_MOSI_Config = 
{ 
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT2,
    .output_level = XMC_GPIO_OUTPUT_LEVEL_HIGH,
    .output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE
  },
  .hw_control = XMC_GPIO_HWCTRL_DISABLED
};

/* Data Receive pin for SPI_MASTER */
const SPI_MASTER_GPIO_t SPI2_MISO = 
{
  .port = (XMC_GPIO_PORT_t *)PORT1_BASE,
  .pin  = (uint8_t)4
};

SPI_MASTER_GPIO_CONFIG_t SPI2_MISO_Config = 
{
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_INPUT_TRISTATE,
  },
                        
};

const SPI_MASTER_GPIO_t SPI2_SCLKOUT = 
{
  .port = (XMC_GPIO_PORT_t *)PORT1_BASE,
  .pin  = (uint8_t)1
};     

const SPI_MASTER_GPIO_CONFIG_t SPI2_SCLKOUT_Config = 
{ 
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT2,
    .output_level = XMC_GPIO_OUTPUT_LEVEL_HIGH,
    .output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE
}
};

XMC_SPI_CH_CONFIG_t SPI2_Channel_Config =
{
  .baudrate = 10000000U,
  .bus_mode = (XMC_SPI_CH_BUS_MODE_t)XMC_SPI_CH_BUS_MODE_MASTER,
  .selo_inversion = XMC_SPI_CH_SLAVE_SEL_INV_TO_MSLS,
  .parity_mode = XMC_USIC_CH_PARITY_MODE_NONE
};
              

const SPI_MASTER_CONFIG_t SPI2_Config  = 
{
  .channel_config          = &SPI2_Channel_Config,
  .fptr_spi_master_config  = SPI2_lInit,
  /* FIFO configuration */
  .tx_fifo_size            = (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
  .rx_fifo_size            = (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
  /* Clock Settings */
  .shift_clk_passive_level = XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED, 
  .slave_select_lines      = (uint8_t)0,
  .leading_trailing_delay  = (uint8_t)2,
  .spi_master_config_mode  = XMC_SPI_CH_MODE_STANDARD, /* spi master initial mode configured mode */
  .transmit_mode           = SPI_MASTER_TRANSFER_MODE_DIRECT,
  .receive_mode            = SPI_MASTER_TRANSFER_MODE_DIRECT,
   
  .tx_cbhandler            = NULL,
  .rx_cbhandler            = NULL,
  .parity_cbhandler        = NULL,
  .mosi_0_pin              = &SPI2_MOSI, /*!< mosi0 pin pointer*/
  .mosi_0_pin_config       = &SPI2_MOSI_Config,
  .mosi_1_pin              = &SPI2_MISO,
  .mosi_1_pin_config       = &SPI2_MISO_Config,
  .mosi_2_pin              = NULL,
  .mosi_2_pin_config       = NULL,
  .mosi_3_pin              = NULL,
  .mosi_3_pin_config       = NULL,
  .sclk_out_pin_config     = &SPI2_SCLKOUT_Config,
  .sclk_out_pin            = &SPI2_SCLKOUT,
  .slave_select_pin        = {NULL, NULL,
                              NULL, NULL,
                              NULL, NULL,
                              NULL, NULL
                             },
  .slave_select_pin_config = {NULL, NULL,
                              NULL, NULL,
                              NULL, NULL,
                              NULL, NULL
                             },

  .tx_sr   = (SPI_MASTER_SR_ID_t)SPI_MASTER_SR_ID_0,
  .rx_sr   = (SPI_MASTER_SR_ID_t)SPI_MASTER_SR_ID_0,
};
                           
SPI_MASTER_RUNTIME_t SPI2_runtime =
{
  .spi_master_mode = XMC_SPI_CH_MODE_STANDARD, /* spi master transmission mode */
  .word_length     = 8U,
                       
  #ifdef USIC0_C0_DX0_P1_4
  .dx0_input = SPI_MASTER_INPUT_B,
  #else
  .dx0_input = SPI_MASTER_INPUT_INVALID,
  #endif

  #ifdef USIC0_C0_DX0_P1_5
  .dx0_input_half_duplex = SPI_MASTER_INPUT_B,
  #else
  .dx0_input_half_duplex = SPI_MASTER_INPUT_INVALID,
  #endif
                           
  .tx_data_dummy = false,
  .rx_data_dummy = true,
  .tx_busy = false,
  .rx_busy = false
};
                  
SPI_MASTER_t SPI2 =
{
  .channel = XMC_SPI0_CH0, /* USIC channel */
  .config  = &SPI2_Config, /* spi master configuration structure pointer */
  .runtime = &SPI2_runtime,
};
                          
/*
 * @brief Configure the port registers and data input registers of SPI channel
 *
 * @param[in] handle Pointer to an object of SPI_MASTER configuration
 */
static SPI_MASTER_STATUS_t SPI2_lInit(void)
{
  SPI_MASTER_STATUS_t status;
  status = SPI_MASTER_STATUS_SUCCESS; 
  /* LLD initialization */
  XMC_SPI_CH_Init(XMC_SPI0_CH0, &SPI2_Channel_Config);
                             
  XMC_SPI_CH_DisableFEM(XMC_SPI0_CH0);
                              
  XMC_SPI_CH_SetBitOrderMsbFirst(XMC_SPI0_CH0);
          
  XMC_SPI_CH_SetWordLength(XMC_SPI0_CH0, (uint8_t)8);

  XMC_SPI_CH_SetFrameLength(XMC_SPI0_CH0, (uint8_t)64);

  /* Configure the clock polarity and clock delay */
  XMC_SPI_CH_ConfigureShiftClockOutput(XMC_SPI0_CH0,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK);
  /* Configure Leading/Trailing delay */
  XMC_SPI_CH_SetSlaveSelectDelay(XMC_SPI0_CH0, 2U);

               
  /* Configure the input pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, (uint8_t)4, &SPI2_MISO_Config.port_config);

  /* Configure the data input line selected */
  XMC_SPI_CH_SetInputSource(XMC_SPI0_CH0, XMC_SPI_CH_INPUT_DIN0, (uint8_t)SPI_MASTER_INPUT_B);
  /* Start the SPI_Channel */
  XMC_SPI_CH_Start(XMC_SPI0_CH0);

  /* Configure the output pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, (uint8_t)5, &SPI2_MOSI_Config.port_config);
    
  /* Initialize SPI SCLK out pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, (uint8_t)1, &SPI2_SCLKOUT_Config.port_config);

  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI0_CH0,
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
                                      (uint32_t)SPI_MASTER_SR_ID_0);
            
  /* Configure transmit FIFO settings */
  XMC_USIC_CH_TXFIFO_Configure(XMC_SPI0_CH0,
                               16U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               1U);

  /* Configure the service interrupt nodes for standard transmit FIFO events */
               
  /* Configure receive FIFO settings */
  XMC_USIC_CH_RXFIFO_Configure(XMC_SPI0_CH0,
                               0U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               15U);
             
  return status;
}
static SPI_MASTER_STATUS_t SPI3_lInit(void);
/* Data Transmit pin from SPI_MASTER */
const SPI_MASTER_GPIO_t SPI3_MOSI = 
{
  .port = (XMC_GPIO_PORT_t *)PORT5_BASE,
  .pin  = (uint8_t)0
};         
                                      
SPI_MASTER_GPIO_CONFIG_t SPI3_MOSI_Config = 
{ 
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT1,
    .output_level = XMC_GPIO_OUTPUT_LEVEL_HIGH,
    .output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE
  },
  .hw_control = XMC_GPIO_HWCTRL_DISABLED
};

/* Data Receive pin for SPI_MASTER */
const SPI_MASTER_GPIO_t SPI3_MISO = 
{
  .port = (XMC_GPIO_PORT_t *)PORT5_BASE,
  .pin  = (uint8_t)1
};

SPI_MASTER_GPIO_CONFIG_t SPI3_MISO_Config = 
{
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_INPUT_TRISTATE,
  },
                        
};

const SPI_MASTER_GPIO_t SPI3_SCLKOUT = 
{
  .port = (XMC_GPIO_PORT_t *)PORT5_BASE,
  .pin  = (uint8_t)2
};     

const SPI_MASTER_GPIO_CONFIG_t SPI3_SCLKOUT_Config = 
{ 
  .port_config = 
  {
    .mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT1,
    .output_level = XMC_GPIO_OUTPUT_LEVEL_HIGH,
    .output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE
}
};

XMC_SPI_CH_CONFIG_t SPI3_Channel_Config =
{
  .baudrate = 10000000U,
  .bus_mode = (XMC_SPI_CH_BUS_MODE_t)XMC_SPI_CH_BUS_MODE_MASTER,
  .selo_inversion = XMC_SPI_CH_SLAVE_SEL_INV_TO_MSLS,
  .parity_mode = XMC_USIC_CH_PARITY_MODE_NONE
};
              

const SPI_MASTER_CONFIG_t SPI3_Config  = 
{
  .channel_config          = &SPI3_Channel_Config,
  .fptr_spi_master_config  = SPI3_lInit,
  /* FIFO configuration */
  .tx_fifo_size            = (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
  .rx_fifo_size            = (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
  /* Clock Settings */
  .shift_clk_passive_level = XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED, 
  .slave_select_lines      = (uint8_t)0,
  .leading_trailing_delay  = (uint8_t)2,
  .spi_master_config_mode  = XMC_SPI_CH_MODE_STANDARD, /* spi master initial mode configured mode */
  .transmit_mode           = SPI_MASTER_TRANSFER_MODE_DIRECT,
  .receive_mode            = SPI_MASTER_TRANSFER_MODE_DIRECT,
   
  .tx_cbhandler            = NULL,
  .rx_cbhandler            = NULL,
  .parity_cbhandler        = NULL,
  .mosi_0_pin              = &SPI3_MOSI, /*!< mosi0 pin pointer*/
  .mosi_0_pin_config       = &SPI3_MOSI_Config,
  .mosi_1_pin              = &SPI3_MISO,
  .mosi_1_pin_config       = &SPI3_MISO_Config,
  .mosi_2_pin              = NULL,
  .mosi_2_pin_config       = NULL,
  .mosi_3_pin              = NULL,
  .mosi_3_pin_config       = NULL,
  .sclk_out_pin_config     = &SPI3_SCLKOUT_Config,
  .sclk_out_pin            = &SPI3_SCLKOUT,
  .slave_select_pin        = {NULL, NULL,
                              NULL, NULL,
                              NULL, NULL,
                              NULL, NULL
                             },
  .slave_select_pin_config = {NULL, NULL,
                              NULL, NULL,
                              NULL, NULL,
                              NULL, NULL
                             },

  .tx_sr   = (SPI_MASTER_SR_ID_t)SPI_MASTER_SR_ID_0,
  .rx_sr   = (SPI_MASTER_SR_ID_t)SPI_MASTER_SR_ID_0,
};
                           
SPI_MASTER_RUNTIME_t SPI3_runtime =
{
  .spi_master_mode = XMC_SPI_CH_MODE_STANDARD, /* spi master transmission mode */
  .word_length     = 8U,
                       
  #ifdef USIC2_C0_DX0_P5_1
  .dx0_input = SPI_MASTER_INPUT_A,
  #else
  .dx0_input = SPI_MASTER_INPUT_INVALID,
  #endif

  #ifdef USIC2_C0_DX0_P5_0
  .dx0_input_half_duplex = SPI_MASTER_INPUT_A,
  #else
  .dx0_input_half_duplex = SPI_MASTER_INPUT_INVALID,
  #endif
                           
  .tx_data_dummy = false,
  .rx_data_dummy = true,
  .tx_busy = false,
  .rx_busy = false
};
                  
SPI_MASTER_t SPI3 =
{
  .channel = XMC_SPI2_CH0, /* USIC channel */
  .config  = &SPI3_Config, /* spi master configuration structure pointer */
  .runtime = &SPI3_runtime,
};
                          
/*
 * @brief Configure the port registers and data input registers of SPI channel
 *
 * @param[in] handle Pointer to an object of SPI_MASTER configuration
 */
static SPI_MASTER_STATUS_t SPI3_lInit(void)
{
  SPI_MASTER_STATUS_t status;
  status = SPI_MASTER_STATUS_SUCCESS; 
  /* LLD initialization */
  XMC_SPI_CH_Init(XMC_SPI2_CH0, &SPI3_Channel_Config);
                             
  XMC_SPI_CH_DisableFEM(XMC_SPI2_CH0);
                              
  XMC_SPI_CH_SetBitOrderMsbFirst(XMC_SPI2_CH0);
          
  XMC_SPI_CH_SetWordLength(XMC_SPI2_CH0, (uint8_t)8);

  XMC_SPI_CH_SetFrameLength(XMC_SPI2_CH0, (uint8_t)64);

  /* Configure the clock polarity and clock delay */
  XMC_SPI_CH_ConfigureShiftClockOutput(XMC_SPI2_CH0,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK);
  /* Configure Leading/Trailing delay */
  XMC_SPI_CH_SetSlaveSelectDelay(XMC_SPI2_CH0, 2U);

               
  /* Configure the input pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT5_BASE, (uint8_t)1, &SPI3_MISO_Config.port_config);

  /* Configure the data input line selected */
  XMC_SPI_CH_SetInputSource(XMC_SPI2_CH0, XMC_SPI_CH_INPUT_DIN0, (uint8_t)SPI_MASTER_INPUT_A);
  /* Start the SPI_Channel */
  XMC_SPI_CH_Start(XMC_SPI2_CH0);

  /* Configure the output pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT5_BASE, (uint8_t)0, &SPI3_MOSI_Config.port_config);
    
  /* Initialize SPI SCLK out pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT5_BASE, (uint8_t)2, &SPI3_SCLKOUT_Config.port_config);

  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI2_CH0,
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
                                      (uint32_t)SPI_MASTER_SR_ID_0);
            
  /* Configure transmit FIFO settings */
  XMC_USIC_CH_TXFIFO_Configure(XMC_SPI2_CH0,
                               16U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               1U);

  /* Configure the service interrupt nodes for standard transmit FIFO events */
               
  /* Configure receive FIFO settings */
  XMC_USIC_CH_RXFIFO_Configure(XMC_SPI2_CH0,
                               0U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               15U);
             
  return status;
}
